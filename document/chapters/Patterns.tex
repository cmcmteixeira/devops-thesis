
\chapter{ Patterns } \label{chap:patterns}
		\begin{pattern}{Team Orchestration}
			\context{When you have a project that you want to execute you will need to assign one or several teams and/or persons to that project. Because of you project complexity you have to allocate people with different expertises.}
			\problem{How do you ochestrate your team(s) in order to maximize you chances of success ?}
			\forces{
				\begin{itemize}
					\item Teams should share objectives and be able to have their objectives aligned with the project objectives.
					\item Knowledge should spread across project intervinients.
					\item It may not be possible to have all expertises working in parallel in the same project.
					\item Teams should be able to colaborate.
				\end{itemize}
			}
			\solution{
				A team should be looked as a unit that can, on their own, produce the results and functionalities necessary for the project. This means that teams should usually be multidisciplinary and capable of communicating efficiently.
				
				Teams should also not have an imposed hierarchical structure and should be allowed to organize themselves.
				
				In terms of size teams should not exceed the 9 elements, this small size allows teams to communicate better and to be able to self-organize.

				Sometimes, due to lack of work some members of a team can accumulate more than one project at a time.

			}
		\end{pattern}

		\begin{pattern}{Version Control Organization}
			\context{
				You are using Git as a VCS tool and your team, having multiple people working on the same project and pushing code to the same repository, runs into situtations like:
					\begin{itemize}
						\item What is the code currently in production ?
						\item What was the code developed for a specific feature ?
					\end{itemize}
			}
			\problem{How do you setup you version control branching strategy so that you can infer valuable information about your current state and past events ?}
			\forces{
				\begin{itemize}
					\item Having to many branches may be complicated to manage.
					\item Having to few branches may make you loose valuable information.
				\end{itemize}

			}
			\solution{
				There are several ways you can manage your VCS branching. The main ones are:
				\begin{itemize}
					\item \textbf{GitFlow} specifies that at any given time two branches should be active. This branches are the \textbf{master} and \textbf{develop} ones. The code present in the master only contains shippable code. The \textit{develop} branch contains the most recent working version of your code. This branch should not contain non working code but it may contain, for instance, features that have not been through a QA process. Adding to this two branches there are additional branches called \textit{feature branches}. This branches represent a new feature under development and there should be one \textit{feature branch} per feature. When a feature is implemented it should be merged into the \textit{develop} branch. If that feature and the previous ones are considered production ready then the \textit{develop} branch should be merged into the \textit{master} one.

					Finally, if at some time you need to create an hotfix, you can do it by creating a new \textit{hotfix} branch with the content of the \textit{master} branch, applying the changes and merging it back into the \textit{master} branch.

					\item \textbf{Feature Branches} can be seen as a subset of the \textbf{Gitflow} strategy. Instead of having a \textit{develop} branch, this strategy only uses the \textit{master} and \textit{feature} branches The \textit{master} branch holds tested and functioning code, the \textit{feature} branches (one for each feature) hold the code of the correspondant feature. When a feature is ready and tested it is merged from the \textit{feature} branch into the \textit{master} branch.

					\item \textbf{Gitlab Flow}
					\item \textbf{Github Flow}

				\end{itemize}
			}

		\end{pattern}
	
		\begin{pattern}{Cloud}
			\context{In order to have computing power you have to \textbf{acquire} \textbf{computing resources}. This resources can be used to perform a number of functions:
				\begin{itemize}
					\item performing \textbf{large complex operations}.  
					\item supporting a \textbf{website} or a \textbf{web platform}.
					\item any other kind of \textbf{computing task}
				\end{itemize}
					This resources should be accessible and configurable and there should not be a need to physically connect to it in order to control them.
				}

			\problem{Owning computing resources is essential or at least advantageous to you or your business so the question is how do you acquire and maintain computing resources in a efficient way ?}
			\forces{
				\begin{itemize}
					\item Acquiring hardware may require significant upfront costs.
					\item Depending on the ammount of hardware you have to manage, a person, team or department may be needed to maintain it. 
					\item Different services may provide different levels of customization/control over operative system 
					\item Sometimes due to a variation in your needs you may want to scale both up or down the ammount of resources you allocated.
					\item Applications may have very specific needs both in terms of harware and environment where they run.
				\end{itemize}
			}
			\solution{
				Solutions for this problem can be seen as belonging to three categories:
				\begin{itemize}
					\item \textbf{Purchasing} and maintaining your own \textbf{hardware} allows you to have full control over your infrastructure. You can control, for instance, in which machine does a specific applications run, how that machine is configured, etc. This option represents therefore the \textbf{highest level of customization} and \textbf{control}. 

					In the \textbf{downside} this options usually means that you \textbf{have to purchase hardware} and that you either \textbf{acquire more resources than what you need} or you risk \textbf{not having enough resources} to answer increasing computing needs. Additionally you will have to \textbf{create} and \textbf{support} a team or department to \textbf{manage the infrastructure}. 

					\item When using \textbf{IaaS} there is no need to purchase anything upfront. In this \textbf{pay-as-you-go} model you only pay for what you consume and you are able to \textbf{increase/decrease} the size and/or number of \textbf{resources} you are using. With this model the responsability for \textbf{maintaining and setting up infrastructure} is shifted to the cloud provider. 

					IaaS providers usually allow you to have some degree of customization  like choosing the operating system and resources available(CPU cores, memory, etc) but lower level configurations will not be available. As a matter of fact, most cloud providers use virtual machines to run their clients applications meaning that you will not be able to tweak network configurations or choose exactly wich machine runs what. IaaS \textbf{reduces} therefore the \textbf{level of control} in comparisson to hosting your own infrastructure.
					
					\item \textbf{PaaS} follows the same \textbf{pay-as-you-go} model as as IaaS meaning that you can also \textbf{increase/decrease} the size and/or number of \textbf{resources} you use. 

					PaaS represents the \textbf{smallest} level of \textbf{customization} but at the same time allows you to use already \textbf{pre-configured environments } in which you can run your applications.


				\end{itemize}
			}
		\end{pattern}



		\begin{pattern}{Reproducible Environments}
			\context{
				Because you have \textbf{several instances} of your software, you want to maintain \textit{consistency} across all of them. 
				Consistency is important because it will allow to have reproducibility and will give you some guarantees that you can setup new instances of your software.
			}
			
			\forces{
				\begin{itemize}
					\item Having a complete copy of your environment (OS's, libraries, etc) may create large images.
					\item You may want to have several running instances of different environments in the same machine.
					\item Some of your dependencies may be fetched from external providers.
					\item You may want to update or change the environment.
				\end{itemize}	

			}
			
			\solution{
				\begin{itemize}
					\item Using \textbf{scripts} usually means \textbf{describing you environment} in the form of a text \textbf{file}. This \textbf{file} is then \textbf{executed/interpreted} inside an \textbf{environment} in order to create the desired state. 

					Because scripts do not contain the dependencies you need, you usually have to \textbf{rely} on \textbf{external providers}. If for instance one provider shuts down your script will not be able to complete.
					

					In case you need to \textbf{update} your setup, depending on the change and the tool you use you may need to \textbf{run} the script \textbf{again}, run only the part you modified or reset the machine and run everything again.

					Because scripts are just text files they often represent the most efficient alternative in terms of memory.

					\item \textbf{Containers} \TODO(containers) 

					
					\item Using \textbf{virtual machines} an environment can be created by creating an image of the operative system with all dependencies installed. This image can then be replicated across different projects. If the need to change dependencies arise a new image can be created. 
					
				\end{itemize}	
			}
		\end{pattern}


		\begin{pattern}{Deploying new instances}
			\context{
				You have decided to increase your computing resources \textbf{horizontally} in order to increase your hability to handle a bigger load of tasks. Depending on what type of \textit{Cloud} you choose to use new resources were allocated. 
			}
			\problem{
				How do you deploy your application ?
			}

			\forces{
				\begin{itemize}
					\item You want to have guarantees that a deploy will be successfull.
					\item You want deployments to be reliable. 
					\item You want to be able to deploy new instances as fast as possible.
				\end{itemize}
			}
			\solution{
				In order have an efficient deploy both in terms of reliability and speed you should have some sort of \TODO{reproducibility} and depending on your choice for setting up your environment (\textit{Reproducible Environments}) there are different ways you can manage the deploy:
				\begin{itemize}
					\item If you have chosen \textit{Containers} you can simply pull the container from a container registry and run it in your new instance. With this approach you will have a high degree of certainty that your instance will behave as you predict. Because containers are generally lightweight you will be able to download them fairly quickly. You will, nevertheless be dependant on you container registry service.
					\item If you have chosen \textit{Virtual Machine}
					\item If you have chosen \textit{Scripts}
					\item If you have chosen \textit{Manual}
				\end{itemize}
			}
		\end{pattern}

		\begin{pattern}{Scalling}
			\context{
				Having a 1:1 ratio between your needs and your resources may be easy to achieve if your needs are fixed in time. If, however, your needs fluctuate as a result of, for instance, new users accessing your application you would want to be able to \textbf{increase} or \textbf{decrease} (in case users numbers drop) the \textbf{resource} allocated.
			}
			\problem{
				What strategy do you choose to increase your computing power ? 
			}
			\forces{
				\begin{itemize}
					\item Costs are a factor.
					\item You want to change the allocated resources quantity without having to stop the existing application(s).
					\item Your application may have need to keep state.
					\item You may not have an upper limit for the amount of resources you will be using. 
				\end{itemize}	

			}
			\solution{
				Usually if your are using the \textit{Cloud} you can easily allocate new machines or increase the CPU cores, RAM, Disk Space, etc of your current machine(s). This two options represent the two existing approaches to scale your computing resources.
				The first one (increasing the number of machines) is usually refered to as \textbf{Horizontal Scalling} and second approach (increasing the resources of each machine) is usually refered to as \textbf{Vertical Scalling}.

				\textbf{Horizontal Scalling} usually is the \textbf{cheaper} option and allows for \textbf{no downtime} when upgrading (the existing machine can be put into production while the old one is running). This approach will also allow you to \textbf{scale} virtually \textbf{without} a \textbf{limit}. On the downside, this approach will force to have some considerations in mind concerning state keeping. If you have a need to keep sessions, for instance, and you are storing them in the machine, the new machines will not have access to that.  

				\textbf{Vertical Scalling} is usually more expensive and depending on your \textit{Cloud} provider may have associated downtime. \textbf{Verical Scalling} also has a maximum amount of resources you can allocate to a single machine. On the upside if you scale vertically(and have only one instance) you can keep the state of your application inside your machine. 

				Both approaches can be combined in order to accomodate your needs.
			}
		\end{pattern}


		\begin{pattern}{Continuous Integration}
			\context{Having several people collaborating into the same project can be challenging. If a developer, unaware that introduced an error, pushes code it into the team repository a long time may go by before an error is even identified. After that the error needs to be identified and, because the code that introduced the error was pushed a long time ago, it may no seem obvious where the error is. }
			\problem{How do you detect early if some error has been introduced into your code?}
			\forces{
				\begin{itemize}
					\item Running your entire test suit before pushing code may take to much time.
					\item It can be challenging to setup an environment simillar to the production one in your local machine.
					\item Your environment may need to be different from the production one(you may need some extra tools to aid you developing).
					\item Your environment may be subject to bias (ex:  case where you may manually set an environment variable that you code uses).
				\end{itemize}

			}
			\solution{
				Use (or develop) an automatic continuous integration(CI) system. This system should detect when code is pushed to your repository and then run the following steps:
				\begin{itemize}
					\item \textbf{Build} . Building your software consists in, depending on your choice for  \textit{Reproducible Environments}, building your environment, then fetching all required dependencies and finally compiling the code(if needed).
					\item \textbf{Test} your build. When your build is successfull you should run your test suite against that build in order to check if everything is running according to plan. 
					\item \textbf{Notify} If any of the previous steps fails you should notify the developer that checked the code and any other people to whom the build integration status is relevant.  
				\end{itemize}
			}
		\end{pattern}





		\begin{pattern}{Communication}

		\end{pattern}
