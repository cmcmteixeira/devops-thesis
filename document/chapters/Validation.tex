\chapter{ Validation } \label{chap:validation}
In this chapter we describe validation process for the pattern language presented in the chapter \ref{chap:patterns}.

	\section{Methodology}
	The methodology used to validate the pattern language defined in chapter \ref{chap:patterns} had 3 main steps. \\
	The first step was to identify a company that wanted to incorporate some of the DevOps ideals into their workflow. Then, a process of identification of possible improvements would be done and a set of metrics would be created that would indicate if the process was successful or not. \\
	The pattern language would then be used to try to improve the identified situations. \\
	Finally, the indicators would be measured again. If the indicators improved, then the pattern language was able to guide a successful adoption of DevOps practices.
       \subsection{Ventureoak}
        We choose to do our validation at VentureOak.
        Ventureoak is a startup currently operating at UPTEC, Porto that started its activity in 2014. Having more than 20 employees, Ventureoak focus is on developing software products for other companies and in offering consultancy solutions both in the product idealization and developing phases. \\
        At Ventureoak projects have usually a short duration - 3 to 6 months - and they usually target the web market. Several projects are developed concurrently at Ventureoak by teams of 2 to 6 elements. This teams are self organizing and are usually composed of developers. \\
        \subsection{Objecties \& Metrics}
        Before beginning the study we identified what were the improvements we wanted to perform. By talking with the company we chose this ones:
        \begin{itemize}
            \item Reduction of the need for developers to handle deployments for the staging environment.
            \item Reduction of the time it took to setup the project in the developers machines.
            \item Improve consistency across the developers machines in order to reduce configuration errors.
            \item The company wanted to start migrating projects to the newer version of PHP.
        \end{itemize}
        With these objectives in mind, we defined the follwoing metrics:
        \begin{itemize}
  			\item Deployment strategy
				\item Deployment duration
				\item Deployment cadency
				\item Environment setup strategy
				\item Environment setup time
				\item Ease to make environment changes
				\item Build errors frequency
			\end{itemize}
			\subsection{Initial State}
			The initial values for each metric were as follows:
			\begin{table}[h!]
				\begin{center}
					\begin{tabular}{| c | c | c |}
						\hline
	 					\textbf{Metric} & \textbf{Observed Value} \\ \hline
	 					Deployment strategy (staging) 		& Manual  \\ \hline
						Deployment duration (staging) 		& 3 to 10 minutes \\ \hline
						Deployment cadency (staging)  		& When needed \\ \hline
						Environment setup strategy			& Manual \\ \hline
						Environment setup time 				& 5 minutes to several hours depending on the developer level \\ \hline
						Ease to make environment changes 	& Low \\ \hline
						Build errors frequency				& Low \\ \hline
					\end{tabular}
				\end{center}
				\caption{Initial metrics identified}
			\end{table}
			\subsection{Adoption Process}
			The adoption process was done in a period of two weeks in one of the projects being developed at Ventureoak. The project was composed of three services. Two of the services used PHP and the remaining service used Javascript. There were additionally, two types of database being used: Redis and MongoDB. \\
            \subsubsection*{Reproducible Environments}
            Having defined that there was a need to reduce the time it took to configure new environments and to improve the consistency of environments, it was obvious that the \textit{Reproducible environment} pattern should be used as it was an exact fit. \\
            This pattern presented us with three possible solutions. Wanting to have an environment as similar as possible with the production one were each service would run separately and because we had to have different versions of PHP running in different services we choose the Containerization option.
            \subsubsection*{Continuous Integration}
            Wanting to change the environment easily meant that there should be a way for developers to be sure that the environment was correctly specified and that when they changed something that would not arm the system. Additionally, having a need to decrease the time it took to deploy the code for the staging environment, it was determined that having a pre-built container image of the environment with the needed code was beneficial. \\
            This lead us to apply the Continuous Integration pattern. \\
            \subsubsection*{Deploying new instances}
            In order to deploy the newer version, we used the \textit{Deploying new instances} pattern. The process was triggered by the CI tool and managed by the cloud provider that would pull the pre-built container image and run it.

			\subsection{Final State}
			In the end of the adoption process we measured the defined metrics again obtaining the following results:
			\begin{table}[h!]
				\begin{center}
					\begin{tabular}{| c | c | c |}
						\hline
	 					\textbf{Metric} & \textbf{Observed Value}                       \\ \hline
	 					Deployment strategy (staging) 	    & Automatic                 \\ \hline
						Deployment duration (staging) 	    & 15 minutes                \\ \hline
						Deployment cadency (staging)  	    & On every push             \\ \hline
						Environment set up strategy		    & Automatic                 \\ \hline
						Environment set up time 			    & Dependant on the connection speed, but usually less than 5 minutes  \\ \hline
						Ease to make environment changes    & High                      \\ \hline
						Build errors frequency			    & Medium                    \\ \hline
					\end{tabular}
				\end{center}
				\caption{Results from the use of the pattern language}
				\subsection{Discussion}
				Except for the deployment duration, we observed a significant improvement between what was the initial state and the final one. Additionally, because we automated some of the processes, the ability to determine which version was running in the staging environment could be transferred to any one which could allow Project Managers to set up the staging environment with version the they wanted. \\
				Unfortunately, the validation process only used three patterns from the 13 available. This means that we were only able to measure the effects of 23\% of our pattern language and because of that we considered this process to have been inconclusive.
			\end{table}
